# 状态模式

状态模式就是有限状态机：Finite State Machine。

状态机有3个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。动作不是必须的，也可能只转移状态，不执行任何动作。

举个例子，超级马里奥。马里奥可以变身多种形态，比如小马里奥、超级马里奥、火焰马里奥、帽子马里奥等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始状态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加100积分。

马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。

## 如何实现状态机

3种方法：

1. 分支逻辑法。一堆的if-else或者switch-case语句。不推荐。

2. 查表法。状态机可以用二维表来表示，如下图所示。在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。

   |       | E1(Got Mushroom) | E2(Got Cap) | E3(Got Fire Flower) | E4(Met Monster) |
   | ----- | ---------------- | ----------- | ------------------- | --------------- |
   | SMALL | Super(+100)      | Cap(+200)   | Fire(+300)          | /               |
   | SUPER | /                | Cap(+200)   | Fire(+300)          | Small(-100)     |
   | CAP   | /                | /           | /                   | Small(-200)     |
   | FIRE  | /                | /           | /                   | Small(-300)     |

   备注：表中的斜杠表示不存在这种状态转移。

   相比于分支逻辑的实现方法，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改transition Table和action Table两个二维数组即可。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。

3. 状态模式。

   状态模式将事件触发的状态转移和动作执行逻辑，拆分到不同的状态类中，来避免分支判断逻辑。例如，定义状态的接口，定义了所有的事件。每个状态都是状态接口的实现类。

   实际上，像游戏这种比较复杂的状态机，包含的状态比较多，优先推荐使用查表法。状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以更推荐状态模式。

   有人说查表法处理不了复杂的动作逻辑，但如果保存的是函数的引用，触发事件的时候，就可以实现复杂的处理逻辑了。