# 适配器模式

就是做适配的，将不兼容的接口转换为可兼容的接口。

## 应用场景总结

什么时候需要用到适配器模式呢？

一般来说，适配器模式可以看作是一种“”补偿模式，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。

前面反复提到，适配器模式的应用场景是“接口不兼容”。那在实际开发中，什么情况下才会出现接口不兼容呢？

1. 封装有缺陷的接口设计。假设依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计。

2. 统一多个类的接口设计。某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。举个例子。假设我们的系统要对用户输入的文本做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套调用逻辑来调用各个系统。这个时候，就可以用适配器模式，将所有系统的接口适配为统一的接口定义，这样可以复用调用敏感词过滤的代码。

3. 替换依赖的外部系统。当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。

4. 兼容老版本接口。在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。

5. 适配不同格式的数据。除了适配接口，还可以在不同格式的数据之间进行适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java中的Arrays.asList()也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。

   ```java
   List<string> s = Arrays.asList("Alice","Bob","Sam")
   ```

每种场景都有例子，详见代码。

## 代理、桥接、装饰器、适配器4种设计模式的区别

代理、桥接、装饰器、适配器，这4种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类。

尽管代码结构相似，但4种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。

- 代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。
- 桥接模式：一个类存在两个（或多个）独立变化的维度，可以通过组合的方式，让这两个（或多个维度）可以独立进行扩展。通过组合关系来替代继承关系，避免继承层次的指数级爆炸。例如：监控告警的例子，有不同严重程度的告警类型，如：紧急、严重、致命等。告警支持多种通知方式，如：邮件、手机、微信通知等。不同的紧急程度对应不同的通知渠道。
- 装饰器模式：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。
- 适配器模式：一种事后补救策略。适配器提供跟原始类不同的接口。而代理模式、装饰器模式提供的都是跟原始类相同的接口。
