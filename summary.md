# 总结

## 一. 创建型设计模式

创建型设计模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。

### 1. 单例模式

单例模式用来创建全局唯一的对象。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫做单例模式。

尽管单例是一个很常用的设计模式，但是有些人认为单例是一种反模式（anti-pattern），并不推荐使用，主要理由有以下几点：

- 单例对OOP特性的支持不友好。
- 单例会隐藏类之间的依赖关系。
- 单例对代码的扩展性不友好。
- 单例对代码的可测试性不友好。
- 单例不支持有参数的构造函数。

那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC容器来保证全局唯一性。

有人把单例当做反模式，主张杜绝在项目中使用，有点极端。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局类，我们在其他地方new的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。

### 2. 工厂模式

工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上，如果创建对象的逻辑并不复杂，那我们直接通过new来创建对象就可以了，不需要使用工厂模式。当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。

当每个对象的创建逻辑都比较简单的时候，推荐使用简单工厂模式，将多个对象的创建逻辑放到同一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的工厂类，推荐使用工厂方法模式，将创建逻辑拆分的更细，每个对象的创建逻辑独立到各自的工厂类中。

详细点说，工厂模式的作用有下面4个，这也是判断要不要使用工厂模式最本质的参考标准。

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
- 代码复用：创建代码抽离到独立的工厂类之后可以复用。
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。

### 3. 建造者模式

建造者模式用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。

### 4. 原型模式

原型模式其实就是一种克隆对象的方法。

如果对象的创建成本比较高，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。

这种基于原型来创建对象的方式就叫做原型设计模式（Prototype Design Pattern），简称原型模式。

原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。

如果要拷贝的对象是不可变对象，浅拷贝共享不变对象是没问题的。但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变的复杂多了。操作非常耗时的情况下，我们比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。

## 二. 结构型设计模式

结构型模式主要总结了一些类或对象组合在一起的经典结构。

### 1. 代理模式

代理模式，在不改变原始类接口的情况下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类没有定义接口，并且原始类代码不是我们开发维护的。这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。

静态代理需要针对每个类都创建一个代理类，并且每个代理类中的方法都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。如果是java中，可以使用动态代理来解决。就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。如何实现动态代理呢？如果是java，动态代理的实现很简单，就是用反射语法。go中如何实现，待补充。

代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。

### 2. 桥接模式

一个类存在两个（或多个）独立变化的维度，可以通过组合的方式，让这两个（或多个维度）可以独立进行扩展。

通过组合关系来替代继承关系，避免继承层次的指数级爆炸。

例如：监控告警的例子，有不同严重程度的告警类型，如：紧急、严重、致命等。告警支持多种通知方式，如：邮件、手机、微信通知等。不同的紧急程度对应不同的通知渠道。

桥接模式的代码实现非常简单，但是理解起来稍有难度，并且应用场景也比较局限。

### 3. 装饰器模式

装饰器模式和代理模式很像，代码结构基本都是一致的。

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。

### 4. 适配器模式

代理模式、装饰器模式提供的都是跟原始类相同的接口，而适配器提供跟原始类不同的接口。适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口。

### 5. 门面模式

门面模式原理、实现都非常简单，应用场景比较明确。它通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。

### 6. 组合模式

组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变的非常简洁。组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。

组合模式，将一组对象组织成树形结构，将单个对象（叶子节点）和组合对象（树枝节点）都看作树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。

### 7. 享元模式

所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。

具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保存一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。

## 三. 行为型设计模式

行为型设计模式主要解决的是 “类或对象之间的交互” 问题。

### 1. 观察者模式

观察者模式将观察者和被观察者解耦。

观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。

有同步阻塞、异步非阻塞、进程内、跨进程的实现方式。同步阻塞是最经典的实现方式，主要是为了代码解耦。异步非阻塞除了能实现代码解耦以外，还能提高代码的执行效率。进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。

框架的作用有隐藏实现细节，降低开发难度，实现代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成EventBus框架来达到这样的效果。EventBus翻译为 ”事件总线“，它提供了实现观察者模式的骨架代码。

### 2. 模板模式

模板方法模式在一个方法中定义一个业务逻辑骨架（就是模板），并将某些步骤推迟到子类中实现。可以让子类在不改变业务逻辑整体结构的情况下，重新定义业务逻辑中的某些步骤。包含业务逻辑骨架（模板）的方法就是“模板方法”。这也是模板方法模式名字的由来。

除此之外，我们还讲到回调。回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的 F 函数就是回调函数。A调用B，B反过来又调用A，这种调用机制就叫作回调。

回调可以细分为同步回调和异步回调。从应用场景上看，同步回调更像模板模式，异步回调更像观察者模式。回调跟模板模式的区别，更多的是在代码实现上，而非应用场景上。回调基于组合关系来实现，模板模式基于继承关系来实现。回调比模板模式更加灵活。

### 3. 策略模式

定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里客户端代指使用算法的代码）。

策略模式解耦的是：策略的定义、创建、使用这三部分。

策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。策略的创建由工厂类来完成，封装策略创建的细节。策略模式包含一组可选策略，客户端代码选择使用哪个策略，有2种方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。

在实际的项目开发中，策略模式也比较常用。最常见的应用场景是，利用它来避免冗长的if-else或switch分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。实际上，策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。

### 4. 职责链模式

多个处理器依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完成后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责。

两种场景：

1. 如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。
2. 请求会被所有的处理器都处理一遍，不存在中途终止的情况。

职责链模式常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。

### 5. 迭代器模式

迭代器是用来遍历容器的。容器实际上就是包含一组对象的对象，比如，数组、链表、树、图、跳表。

迭代器模式主要作用是解耦容器代码和遍历代码。大部分编程语言都提供了现成的迭代器可以使用，我们不需要从零开始开发。

遍历集合一般有3种方式：for循环、for-each循环、迭代器遍历。后两者本质上属于同一种，都可以看作迭代器遍历。相对于for循环遍历，利用迭代器来遍历有下面三个优势：

1. 迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可。
2. 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。
3. 迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变的更加容易。

在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。针对这个问题，有2种比较干脆利索的解决方案，来避免出现这种不可预期的运行结果。一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。第一种解决方案比较难实现，因为很难确定迭代器使用结束的时间点。第二种解决方案更加合理，java语言就是采用的这种解决方案。增删元素之后，我们选择 fail-fast 方式，让遍历操作直接抛出运行时异常。
### 6. 状态模式

状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。状态机又叫有限状态机，它由3个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。

针对状态机，我们总结了3种实现方式。

1. 分支逻辑法。利用if-else或者switch-case语句，参照状态转移图，将每一个状态转移直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。
2. 查表法。对于状态很多，状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。
3. 状态模式。对于状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。

### 7. 访问者模式

访问者模式理解比较困难。可以认为对象开了一扇门，用来接收访问者，然后访问者便可在对象内部操作对象。简单来说，对象对访问者进行了授权。这样做能够实现对象和操作的解耦，职责更加单一。对象只管理自身，操作功能安置在访问者中。

访问者模式允许你在结构体中添加行为， 而又不会对结构体造成实际变更。对象只要预留访问者接口`Accept`则后期为对象添加功能的时候就不需要改动对象。

### 8. 备忘录模式

备忘录模式也叫快照（Snapshot）模式，英文翻译是Memento Design Pattern。定义是，在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。

备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。

对于大对象的备份来说，备份占用空间会比较大。比如可以全量备份和增量备份结合，低频全量备份，高频增量备份。

### 9. 命令模式

命令模式在平时工作中并不常用，你稍微了解一下就可以。

落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。但在go中，函数可以直接当做参数传递，并且可以命名函数为一个类型，所以不必使用对象来实现。

命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。

### 10. 解释器模式

解释器模式为某个语言定义它的语法表示，并定义一个解释器来处理这个语法。

解释器模式的代码实现比较灵活，没有固定的模板。前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思路，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。

### 11. 中介模式

中介模式（Mediator Design Pattern）也属于不怎么常用的模式，应用场景比较特殊、有限。但是理解起来并不难。

中介模式的设计思想跟中间层很像，通过引入中介这个中间层，来封装一组对象之间的交互。将这组对象之间的交互委派给中介对象交互，来避免对象之间的直接交互。

观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。不同在于应用场景。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系是错综复杂，既可以是消息的发送者，也可以同时是消息的接收者。

